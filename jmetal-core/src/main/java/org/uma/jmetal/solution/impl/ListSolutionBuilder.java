package org.uma.jmetal.solution.impl;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.function.Supplier;

import org.uma.jmetal.solution.SolutionBuilder;
import org.uma.jmetal.solution.Variable;

/**
 * A {@link ListSolutionBuilder} generates solutions backed by a {@link List}.
 * {@link List}s have homogeneous values, so this builder can only generate
 * solutions like lists of integers, lists of doubles, or lists of any given
 * type of object, but it cannot generate solutions having heterogeneous
 * variables. By default, this builder generate {@link ArrayList} instances, but
 * this can be modified through {@link #setListSupplier(Supplier)}.
 * 
 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
 *
 * @param <Value>
 *            the type of values to store in the {@link List}
 */
public class ListSolutionBuilder<Value> implements SolutionBuilder<List<Value>> {

	private final Map<Integer, Variable<List<Value>, Value>> variables = new HashMap<>();
	private final Map<Variable<List<Value>, Value>, Predicate<? super Value>> validators = new HashMap<>();
	private final Map<Variable<List<Value>, Value>, Value> defaultValues = new HashMap<>();
	private final Map<Variable<List<Value>, Value>, Value> solutionValues = new HashMap<>();
	private Supplier<List<Value>> listSupplier = () -> new ArrayList<>();

	/**
	 * This method allows to change the kind of {@link List} generated by this
	 * {@link ListSolutionBuilder}. The generated {@link List} is assumed to be
	 * empty when generated. If it is not the case, the
	 * {@link ListSolutionBuilder} may behave differently than intended.
	 * 
	 * @param listSupplier
	 *            the {@link Supplier} to use to create lists
	 */
	public void setListSupplier(Supplier<List<Value>> listSupplier) {
		this.listSupplier = listSupplier;
	}

	/**
	 * 
	 * @return the {@link Supplier} used to generate new {@link List}s
	 */
	public Supplier<List<Value>> getListSupplier() {
		return listSupplier;
	}

	/**
	 * 
	 * @return the number of {@link Variable}s managed by this
	 *         {@link ListSolutionBuilder}
	 */
	public int getSize() {
		Optional<Integer> max = variables.keySet().stream().max(Comparator.comparing(i -> i));
		return max.isPresent() ? max.get() + 1 : 0;
	}

	/**
	 * 
	 * @param index
	 *            index of the {@link Variable}
	 * @return the {@link Variable}
	 * @throws IndexOutOfBoundsException
	 *             if no {@link Variable} correspond to the index
	 */
	public Variable<List<Value>, Value> getVariable(int index) {
		return variables.get(index);
	}

	@SuppressWarnings("unchecked")
	@Override
	public <V> void set(Variable<List<Value>, V> variable, V value) {
		if (!variables.containsValue(variable)) {
			throw new UnmanagedVariableException(variable);
		} else if (!validators.get(variable).test((Value) value)) {
			throw new InvalidVariableValueException(variable, value);
		} else {
			solutionValues.put((Variable<List<Value>, Value>) variable, (Value) value);
		}
	}

	@Override
	public List<Value> build() throws UnableToBuildSolutionException {
		List<Value> solution = listSupplier.get();
		Optional<Integer> max = variables.keySet().stream().max(Comparator.comparing(i -> i));
		if (!max.isPresent()) {
			// nothing to add
		} else {
			for (int index = 0; index <= max.get(); index++) {
				Variable<List<Value>, Value> variable = variables.get(index);
				if (variable == null) {
					throw new UnableToBuildSolutionException("No variable assigned to index " + index);
				} else if (solutionValues.containsKey(variable)) {
					solution.add(solutionValues.get(variable));
				} else if (defaultValues.containsKey(variable)) {
					solution.add(defaultValues.get(variable));
				} else {
					throw new UnableToBuildSolutionException("No value povided for variable " + variable);
				}
			}
		}
		return solution;
	}

	@Override
	public void reset() {
		solutionValues.clear();
	}

	/**
	 * Create a named {@link Variable}.
	 * 
	 * @param name
	 *            the name of the {@link Variable}
	 */
	public IndexSelector assignVariable(String name) {
		return new IndexSelector(name);
	}

	/**
	 * Create an anonymous {@link Variable}. Its name will mention the index it
	 * reads.
	 */
	public IndexSelector assignVariable() {
		return assignVariable(null);
	}

	public class IndexSelector {

		private final String name;

		public IndexSelector(String name) {
			this.name = name;
		}

		/**
		 * Assign the {@link Variable} to a custom index. All the indexes from 0
		 * to max must be assigned. Indexes can be set in any order, but no
		 * solution can be built if an index is unassigned.
		 * 
		 * @param index
		 *            the index of the {@link Variable}
		 */
		public PredicateSelector toIndex(int index) {
			if (name == null) {
				return new PredicateSelector("[" + index + "]", index);
			} else {
				return new PredicateSelector(name, index);
			}
		}

		/**
		 * Assign the {@link Variable} to the first free index. The size of the
		 * {@link List} increased if necessary.
		 */
		public PredicateSelector toFirstFreeIndex() {
			int index = 0;
			while (variables.keySet().contains(index)) {
				index++;
			}
			return new PredicateSelector(name, index);
		}

	}

	public class PredicateSelector {

		private final String name;
		private final int index;

		public PredicateSelector(String name, int index) {
			this.name = name == null ? "[" + index + "]" : name;
			this.index = index;
		}

		public DefaultValueSelector forValues(Predicate<Value> predicate) {
			return new DefaultValueSelector(name, index, predicate);
		}

		public DefaultValueSelector forAnyValue() {
			return forValues((v) -> true);
		}

	}

	public class DefaultValueSelector {

		private final String name;
		private final int index;
		private final Predicate<Value> predicate;

		public DefaultValueSelector(String name, int index, Predicate<Value> predicate) {
			this.name = name;
			this.index = index;
			this.predicate = predicate;
		}

		private ListVariable<Value> configureBase() {
			ListVariable<Value> variable = new ListVariable<Value>(index) {
				@Override
				public String toString() {
					return name;
				}
			};
			variables.put(index, variable);
			validators.put(variable, predicate);
			return variable;
		}

		public Variable<List<Value>, Value> asMandatoryVariable() {
			return configureBase();
		}

		public Variable<List<Value>, Value> withDefault(Value defaultValue) {
			Variable<List<Value>, Value> variable = configureBase();
			defaultValues.put(variable, defaultValue);
			return variable;
		}

	}

}
