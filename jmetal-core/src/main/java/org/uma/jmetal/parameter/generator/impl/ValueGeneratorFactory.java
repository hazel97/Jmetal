package org.uma.jmetal.parameter.generator.impl;

import java.util.List;
import java.util.Random;

import org.uma.jmetal.parameter.generator.ParameterableValueGenerator;
import org.uma.jmetal.parameter.generator.ValueGenerator;

/**
 * This {@link ValueGeneratorFactory} provide facilities to instantiate usual
 * {@link ValueGenerator}s.
 * 
 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
 * 
 */
public class ValueGeneratorFactory {

	/**
	 * The {@link ValueGenerator} generated by this method provides
	 * {@link Integer}s from within a range.
	 * 
	 * @param min
	 *            the minimal {@link Integer} to generate
	 * @param max
	 *            the maximal {@link Integer} to generate
	 * @return the {@link ValueGenerator} able to generate values from
	 *         <code>min</code> to <code>max</code>
	 */
	public FiniteDiscreteRangeGenerator<Integer> createIntegerRangeGenerator(
			final int min, final int max) {
		return new FiniteDiscreteRangeGenerator<Integer>(max - min + 1,
				new FiniteDiscreteRangeGenerator.SubGenerator<Integer>() {

					@Override
					public Integer generate(int index) {
						return index + min;
					}
				});
	}

	/**
	 * The {@link ValueGenerator} generated by this method provides
	 * {@link Double}s from within a range.
	 * 
	 * @param min
	 *            the minimal {@link Double} to generate
	 * @param max
	 *            the maximal {@link Double} to generate
	 * @return the {@link ValueGenerator} able to generate values from
	 *         <code>min</code> to <code>max</code>
	 */
	public FiniteContinuousRangeGenerator<Double> createDoubleRangeGenerator(final double min,
			final double max) {
		return new FiniteContinuousRangeGenerator<Double>(
				new FiniteContinuousRangeGenerator.SubGenerator<Double>() {

					@Override
					public Double generate(double ratio) {
						return ratio * (max - min) + min;
					}

				});
	}

	public <Value> ValueGenerator<Value> createListBasedGenerator(
			final List<Value> list) {
		return new FiniteDiscreteRangeGenerator<Value>(list.size(),
				new FiniteDiscreteRangeGenerator.SubGenerator<Value>() {

					@Override
					public Value generate(int index) {
						return list.get(index);
					}
				});
	}

	public <Value extends Enum<Value>> ValueGenerator<Value> createEnumBasedGenerator(
			Class<Value> enumeration) {
		final Value[] constants = enumeration.getEnumConstants();
		return new FiniteDiscreteRangeGenerator<Value>(constants.length,
				new FiniteDiscreteRangeGenerator.SubGenerator<Value>() {

					@Override
					public Value generate(int index) {
						return constants[index];
					}
				});
	}

	public <Value> ValueGenerator<Value> createRandomGenerator(
			final FiniteDiscreteRangeGenerator<Value> generator,
			final Random random) {
		return new ValueGenerator<Value>() {

			@Override
			public boolean canGenerate() {
				generator.setIndex(random.nextInt(generator.getMaxIndex() + 1));
				return generator.canGenerate();
			}

			@Override
			public Value generate() {
				return generator.generate();
			}
		};
	}

	public <Value> ValueGenerator<Value> createRandomGenerator(
			FiniteDiscreteRangeGenerator<Value> generator) {
		return createRandomGenerator(generator, new Random());
	}

	public <Value> ValueGenerator<Value> createRandomGenerator(
			final FiniteContinuousRangeGenerator<Value> generator,
			final Random random) {
		return new ValueGenerator<Value>() {

			@Override
			public boolean canGenerate() {
				generator.setRatio(random.nextDouble());
				return generator.canGenerate();
			}

			@Override
			public Value generate() {
				return generator.generate();
			}
		};
	}

	public <Value> ValueGenerator<Value> createRandomGenerator(
			FiniteContinuousRangeGenerator<Value> generator) {
		return createRandomGenerator(generator, new Random());
	}

	public <Value> ValueGenerator<Value> createRandomGenerator(
			ParameterableValueGenerator<Value> generator, Random random) {
		return new RandomGenerator<Value>(generator, random);
	}

}
