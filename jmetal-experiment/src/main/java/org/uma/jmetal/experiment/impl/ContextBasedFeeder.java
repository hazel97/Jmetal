package org.uma.jmetal.experiment.impl;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.WeakHashMap;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.logging.Logger;

import org.uma.jmetal.experiment.ExperimentFeeder;

/**
 * A {@link ContextBasedFeeder} facilitates the implementation of an
 * {@link ExperimentFeeder} for N {@link Type}s of algorithms configured with M
 * {@link Context}s. A normal initialization process for parallel executions
 * would be to instantiate the N {@link Type}s of algorithms M times each and
 * configure them with each {@link Context}, thus NxM
 * instantiations/configurations. {@link ContextBasedFeeder} reduces this effort
 * to a N+M step by introducing bridging {@link Parameter}s.<br/>
 * <br/>
 * A basic use of a {@link ContextBasedFeeder} is the following:
 * <ol>
 * <li>Add the relevant algorithm {@link Type}s with
 * {@link #addType(Supplier)}</li>
 * <li>Add the relevant {@link Context}s with {@link #addContext(Supplier)}</li>
 * <li>Create the required {@link Parameter}s with
 * {@link #createParameter(Class)}</li>
 * <li>Tell how the {@link Parameter}s' value should be retrieved from each
 * {@link Context} with {@link #retrieve(Parameter)}</li>
 * <li>Tell how the {@link Parameter}s' value should be assigned to each
 * {@link Type} of algorithm with {@link #assign(Parameter)}</li>
 * </ol>
 * An example code could be:<br/>
 * <br/>
 * <code>
 * ContextBasedFeeder&lt;Algo> feeder = new ContextBasedFeeder&lt;Algo>();<br/>
 * <br/>
 * Type&lt;Algo1> type1 = feeder.addType(() -> new Algo1());<br/>
 * Type&lt;Algo2> type2 = feeder.addType(() -> new Algo2());<br/>
 * <br/>
 * Context&lt;Context1> context1 = feeder.addContext(() -> new Context1());<br/>
 * Context&lt;Context2> context2 = feeder.addContext(() -> new Context2());<br/>
 * <br/>
 * Parameter&lt;Integer> parameter = feeder.createParameter(Integer.class);<br/>
 * feeder.retrieve(parameter).from(context1).with((context) -> context.getValue());<br/>
 * feeder.retrieve(parameter).from(context2).with((context) -> context.readValue());<br/>
 * feeder.assign(parameter).to(type1).with((algorithm, value) -> algorithm.setValue(value));<br/>
 * feeder.assign(parameter).to(type2).with((algorithm, value) -> algorithm.writeValue(value));<br/>
 * </code> <br/>
 * The {@link Parameter}s are constrained by the {@link Type}s: if a
 * {@link Parameter} is required by a {@link Type} but not provided by a
 * {@link Context}, an exception will be thrown. At the opposite, if a
 * {@link Context} provides a {@link Parameter} which is not used by one or more
 * {@link Type}s, the {@link Parameter} will just not be used for them. A
 * {@link Parameter} which is used by no {@link Type} and no {@link Context} has
 * no impact on the {@link ContextBasedFeeder}.<br/>
 * <br/>
 * {@link Parameter}s can be named by using
 * {@link #createParameter(Class, String)} instead of
 * {@link #createParameter(Class)}. This name is used to override the
 * {@link #toString()} method. Similarly, {@link Type}s and {@link Context}s
 * have their own methods too (the name is applied to the returned object, not
 * the instances generated by the supplier). These methods can be used to make
 * the logs more readable.<br/>
 * <br/>
 * It is possible to manage the {@link Parameter} values in a more advanced way
 * through the method {@link #when(Parameter)}, which allows to specify
 * operations to execute on the value when specific {@link Condition}s hold. An
 * example code is the following:<br/>
 * <br/>
 * <code>
 * feeder.when(parameter).satisfies((value) -> value == 42).inAnyAlgorithm().replaceBy(35);<br/>
 * </code> <br/>
 * More advanced features are available, like the use of a {@link Replacer}
 * instead of a static value or the selection of specific {@link Type}s or
 * {@link Context}s to impact.<br/>
 * <br/>
 * <b>Single Instance Supplier &amp; Concurrency Issues</b><br/>
 * <br/>
 * It is possible to provide a {@link Type} {@link Supplier} which returns
 * always the same instance, but concurrency issues may arise if the same
 * algorithm instance is run twice. Consequently, single instance
 * {@link Supplier}s are not recommended. However, because it is possible to
 * ensure that the {@link Supplier} is called only once, it is not forbidden and
 * no exception will be generated if such a situation arise. Nevertheless, a
 * warning is generated if the same instance is provided by the same
 * {@link Type} {@link Supplier} to help identify simple mistakes. Other kinds
 * of warnings are not supported, though, like if the same instance is generated
 * by a different {@link Supplier}, or if the situation arises with a
 * {@link Context} instance (which is assumed to be read only).
 * 
 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
 *
 * @param <Algorithm>
 */
public class ContextBasedFeeder<Algorithm> implements ExperimentFeeder<Algorithm> {

	private static final Logger log = Logger.getLogger(ContextBasedFeeder.class.getName());
	private final Map<LeafContext<?>, Supplier<?>> contextSuppliers = new LinkedHashMap<>();
	private final Map<LeafType<?>, Supplier<?>> typeSuppliers = new LinkedHashMap<>();
	private final Map<Context<?>, Map<Parameter<?>, Getter<?, ?>>> contextParameters = new HashMap<>();
	private final Map<LeafType<?>, Map<Parameter<?>, Setter<?, ?>>> typeParameters = new HashMap<>();
	private final Map<Parameter<?>, Collection<ReplacementDescriptor<?>>> parameterReplacers = new HashMap<>();

	@Override
	public Iterator<Algorithm> iterator() {
		return new Iterator<Algorithm>() {

			int index = 0;

			@Override
			public boolean hasNext() {
				return index < size();
			}

			@Override
			public Algorithm next() {
				return instantiateAlgorithm(index++);
			}
		};
	}

	/**
	 * 
	 * @return the number of algorithm instances returned by this
	 *         {@link ContextBasedFeeder} (|{@link Type}s| x |{@link Context}s|)
	 */
	public long size() {
		return contextSuppliers.size() * typeSuppliers.size();
	}

	@SuppressWarnings("unchecked")
	private <C, A extends Algorithm, Value> Algorithm instantiateAlgorithm(int algorithmIndex) {
		if (algorithmIndex >= size() || algorithmIndex < 0) {
			throw new IndexOutOfBoundsException("Index: " + algorithmIndex + ", Size: " + size());
		} else {
			Iterator<Entry<LeafContext<?>, Supplier<?>>> contextSupplierIterator = contextSuppliers.entrySet()
					.iterator();
			int algoListSize = typeSuppliers.size();
			while (algorithmIndex >= algoListSize) {
				algorithmIndex -= algoListSize;
				contextSupplierIterator.next();
			}
			Entry<LeafContext<?>, Supplier<?>> contextEntry = contextSupplierIterator.next();
			LeafContext<C> context = (LeafContext<C>) contextEntry.getKey();
			C data = (C) contextEntry.getValue().get();

			Iterator<Entry<LeafType<?>, Supplier<?>>> typeSupplierIterator = typeSuppliers.entrySet().iterator();
			while (algorithmIndex > 0) {
				algorithmIndex--;
				typeSupplierIterator.next();
			}

			Entry<LeafType<?>, Supplier<?>> typeEntry = typeSupplierIterator.next();
			LeafType<A> type = (LeafType<A>) typeEntry.getKey();
			A algorithm = (A) typeEntry.getValue().get();
			if (type.isTypeOf(algorithm)) {
				log.warning("The supplier for " + type + " has provided the same instance several times. "
						+ "Concurrency issues may arise during the execution of the algorithm.");
			} else {
				type.recognize(algorithm);
			}
			context.recognize(algorithm);

			for (Entry<Parameter<?>, Setter<?, ?>> entry : typeParameters.get(type).entrySet()) {
				Parameter<Value> parameter = (Parameter<Value>) entry.getKey();
				Setter<A, Value> setter = (Setter<A, Value>) entry.getValue();

				Getter<C, Value> getter = (Getter<C, Value>) contextParameters.get(context).get(parameter);
				if (getter == null) {
					throw new IllegalStateException("No getter for reading parameter " + parameter + " from context "
							+ context + " for algorithm " + type);
				} else {
					Value value = getter.get(data);

					Collection<ReplacementDescriptor<?>> descriptors = parameterReplacers.get(parameter);
					for (ReplacementDescriptor<?> descriptor : descriptors) {
						ReplacementDescriptor<Value> d = (ReplacementDescriptor<Value>) descriptor;
						if (d.isApplicableOn(algorithm, value)) {
							value = d.apply(value);
							break;
						} else {
							continue;
						}
					}

					setter.set(algorithm, value);
				}
			}

			return algorithm;
		}
	}

	/**
	 * Same as {@link #createParameter(Class, String)} but without a name. The
	 * default string representation of the {@link Parameter} object is used
	 * instead.
	 */
	public <Value> Parameter<Value> createParameter(Class<Value> parameterClass) {
		return addParameter(new Parameter<Value>());
	}

	/**
	 * Create a new intermediary {@link Parameter} which can be used to retrieve
	 * a value from a {@link Context} and assign it to {@link Type} of
	 * algorithm. The name given to a {@link Parameter} is used as its string
	 * representation ({@link #toString()}).
	 * 
	 * @param parameterClass
	 *            the type of value managed by this {@link Parameter}
	 * @param name
	 *            the name of this {@link Parameter}
	 * @return the new {@link Parameter}
	 */
	public <Value> Parameter<Value> createParameter(Class<Value> parameterClass, String name) {
		return addParameter(new Parameter<Value>() {
			@Override
			public String toString() {
				return name;
			}
		});
	}

	private <Value> Parameter<Value> addParameter(Parameter<Value> parameter) {
		parameterReplacers.put(parameter, new LinkedList<>());
		return parameter;
	}

	/**
	 * Remove all the settings related to a given {@link Parameter}. These
	 * settings include:
	 * <ul>
	 * <li>the {@link Setter}s used to apply the {@link Parameter} to various
	 * {@link Type}s</li>
	 * <li>the {@link Getter}s used to read the {@link Parameter} from various
	 * {@link Context}s</li>
	 * <li>the {@link Replacer}s used to refine the {@link Parameter}'s
	 * values</li>
	 * </ul>
	 * 
	 * @param parameter
	 *            the {@link Parameter} to reset
	 */
	public <Value> void resetParameter(Parameter<Value> parameter) {
		for (Map<Parameter<?>, Setter<?, ?>> parameters : typeParameters.values()) {
			parameters.remove(parameter);
		}
		for (Map<Parameter<?>, Getter<?, ?>> parameters : contextParameters.values()) {
			parameters.remove(parameter);
		}
		parameterReplacers.get(parameter).clear();
	}

	/**
	 * A {@link Parameter} acts as a label: it identifies a specific value which
	 * should be retrieved from a {@link Context} and assigned to a {@link Type}
	 * of algorithm for configuration purpose.
	 * 
	 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
	 *
	 * @param <Value>
	 *            The type of value managed by this {@link Parameter}
	 */
	public static class Parameter<Value> {
	}

	/**
	 * Same as {@link #addContext(Supplier)} but with a {@link Supplier} which
	 * always returns the same instance. If concurrent uses of the
	 * {@link Context} instance may occur, prefer to use the other method.
	 */
	public <C> Context<C> addContext(C context) {
		return addContext(() -> context);
	}

	/**
	 * Same as {@link #addContext(Supplier, String)} but without a name. The
	 * default string representation of the {@link Context} object is used
	 * instead.
	 */
	public <C> Context<C> addContext(Supplier<C> supplier) {
		if (supplier == null) {
			throw new NullPointerException("No supplier provided");
		} else {
			return addContext(new LeafContext<C>(), supplier);
		}
	}

	/**
	 * Same as {@link #addContext(Supplier, String)} but with a {@link Supplier}
	 * which always returns the same instance. If concurrent uses of the
	 * {@link Context} instance may occur, prefer to use the other method.
	 */
	public <C> Context<C> addContext(C context, String name) {
		return addContext(() -> context, name);
	}

	/**
	 * Register a new {@link Context} to consider for configuring algorithms.
	 * 
	 * @param supplier
	 *            the {@link Supplier} to use to obtain an instance of the
	 *            {@link Context}
	 * @param name
	 *            the name of the {@link Context}
	 * @return the {@link Context} object identifying them
	 */
	public <C> Context<C> addContext(Supplier<C> supplier, String name) {
		return addContext(new LeafContext<C>() {
			@Override
			public String toString() {
				return name;
			}
		}, supplier);
	}

	private <C> Context<C> addContext(LeafContext<C> context, Supplier<C> supplier) {
		contextSuppliers.put(context, supplier);
		contextParameters.put(context, new HashMap<>());
		return context;
	}

	/**
	 * Identifier of a {@link Context} supplied by a {@link ContextBasedFeeder}.
	 * This {@link Context} is registered through
	 * {@link ContextBasedFeeder#addContext(Supplier)}. Any algorithm configured
	 * with an instance of this {@link Context} is recognized as such and can be
	 * recognized by {@link #isContextOf(Object)}.
	 * 
	 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
	 *
	 * @param <C>
	 */
	public static interface Context<C> {
		/**
		 * 
		 * @param object
		 *            the object to check
		 * @return <code>true</code> if this object is an algorithm configured
		 *         with this {@link Context}, <code>false</code> otherwise
		 */
		public boolean isContextOf(Object object);

		@SafeVarargs
		public static <C> Context<C> compose(Context<? extends C>... subcontexts) {
			return new ComposedContext<C>(subcontexts);
		}
	}

	private static class LeafContext<C> implements Context<C> {
		// TODO try to make it works without such a cache
		WeakHashMap<Object, Void> cache = new WeakHashMap<Object, Void>();

		/**
		 * Weakly store an algorithm in cache to recognize it with
		 * {@link #isContextOf(Object)}. Only the algorithms stored in this
		 * cache can be recognized.
		 */
		private void recognize(Object algorithm) {
			cache.put(algorithm, null);
		}

		@Override
		public boolean isContextOf(Object object) {
			return cache.containsKey(object);
		}
	}

	private static class ComposedContext<C> implements Context<C> {
		private final Collection<Context<? extends C>> subcontexts;

		@SafeVarargs
		private ComposedContext(Context<? extends C>... subcontexts) {
			this(Arrays.asList(subcontexts));
		}

		private ComposedContext(Collection<Context<? extends C>> subcontexts) {
			this.subcontexts = new HashSet<>(subcontexts);
		}

		@Override
		public boolean isContextOf(Object object) {
			return subcontexts.parallelStream().anyMatch((c) -> c.isContextOf(object));
		}

		public Collection<Context<? extends C>> getSubContexts() {
			return Collections.unmodifiableCollection(subcontexts);
		}

	}

	/**
	 * Same as {@link #addType(Supplier, String)} but without a name. The
	 * default string representation of the {@link Type} object is used instead.
	 */
	public <A extends Algorithm> Type<A> addType(Supplier<A> supplier) {
		return addType(new LeafType<A>(), supplier);
	}

	/**
	 * Register a new {@link Type} of algorithm to generate.
	 * 
	 * @param supplier
	 *            the {@link Supplier} to use to obtain an instance of the
	 *            algorithm
	 * @param name
	 *            the name of the algorithm
	 * @return the {@link Type} of the algorithm
	 */
	public <A extends Algorithm> Type<A> addType(Supplier<A> supplier, String name) {
		return addType(new LeafType<A>() {
			@Override
			public String toString() {
				return name;
			}
		}, supplier);
	}

	private <A extends Algorithm> Type<A> addType(LeafType<A> type, Supplier<A> supplier) {
		typeSuppliers.put(type, supplier);
		typeParameters.put(type, new HashMap<>());
		return type;
	}

	/**
	 * Identifier of a {@link Type} of algorithm supplied by a
	 * {@link ContextBasedFeeder}. This {@link Type} is registered through
	 * {@link ContextBasedFeeder#addType(Supplier)}. Any algorithm generated by
	 * the registered {@link Supplier} is covered by this {@link Type} and can
	 * be recognized by {@link #isTypeOf(Object)}.
	 * 
	 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
	 *
	 * @param <Algorithm>
	 */
	public static interface Type<Algorithm> {
		/**
		 * 
		 * @param object
		 *            the object to check
		 * @return <code>true</code> if this object is an algorithm of this
		 *         {@link Type}, <code>false</code> otherwise
		 */
		public boolean isTypeOf(Object object);

		@SafeVarargs
		public static <Algorithm> Type<Algorithm> compose(Type<? extends Algorithm>... subtypes) {
			return new ComposedType<Algorithm>(subtypes);
		}

	}

	private static class LeafType<Algorithm> implements Type<Algorithm> {
		// TODO try to make it works without such a cache
		WeakHashMap<Algorithm, Void> cache = new WeakHashMap<Algorithm, Void>();

		/**
		 * Weakly store an algorithm in cache to recognize it with
		 * {@link #isTypeOf(Object)}. Only the algorithms stored in this cache
		 * can be recognized.
		 */
		private void recognize(Algorithm algorithm) {
			cache.put(algorithm, null);
		}

		@Override
		public boolean isTypeOf(Object object) {
			return cache.containsKey(object);
		}

	}

	private static class ComposedType<Algorithm> implements Type<Algorithm> {
		private final Collection<Type<? extends Algorithm>> subtypes;

		@SafeVarargs
		private ComposedType(Type<? extends Algorithm>... subtypes) {
			this(Arrays.asList(subtypes));
		}

		private ComposedType(Collection<Type<? extends Algorithm>> subtypes) {
			this.subtypes = new HashSet<>(subtypes);
		}

		@Override
		public boolean isTypeOf(Object object) {
			return subtypes.parallelStream().anyMatch((t) -> t.isTypeOf(object));
		}

		public Collection<Type<? extends Algorithm>> getSubTypes() {
			return Collections.unmodifiableCollection(subtypes);
		}
	}

	/**
	 * Use this method to tell how to retrieve a {@link Parameter} value from a
	 * given {@link Context}.
	 * 
	 * @param parameter
	 *            the {@link Parameter} to retrieve
	 */
	public <Value> ValueRetriever<Value> retrieve(Parameter<Value> parameter) {
		return new ValueRetriever<Value>(parameter);
	}

	public class ValueRetriever<Value> {
		private final Parameter<Value> parameter;

		private ValueRetriever(Parameter<Value> parameter) {
			this.parameter = parameter;
		}

		/**
		 * @param context
		 *            the {@link Context} to read
		 */
		public <C> ContextReader<C, Value> from(Context<C> context) {
			return new ContextReader<C, Value>(parameter, context);
		}
	}

	public class ContextReader<C, Value> {
		private final Parameter<Value> parameter;
		private final Context<C> context;

		private ContextReader(Parameter<Value> parameter, Context<C> context) {
			this.parameter = parameter;
			this.context = context;
		}

		/**
		 * 
		 * @param getter
		 *            the {@link Getter} to use for reading the
		 *            {@link Parameter} from the {@link Context}.
		 */
		public void with(Getter<C, Value> getter) {
			if (context instanceof LeafContext) {
				store((LeafContext<C>) context, getter);
			} else if (context instanceof ComposedContext) {
				List<ComposedContext<? extends C>> remaining = new LinkedList<>();
				remaining.add((ComposedContext<C>) context);
				while (!remaining.isEmpty()) {
					ComposedContext<? extends C> composedContext = remaining.remove(0);
					for (Context<? extends C> subcontext : composedContext.getSubContexts()) {
						if (subcontext instanceof LeafContext) {
							store((LeafContext<? extends C>) subcontext, getter);
						} else if (subcontext instanceof ComposedContext) {
							remaining.add((ComposedContext<? extends C>) subcontext);
						} else {
							throw new RuntimeException("Unmanaged case");
						}
					}
				}
			} else {
				throw new RuntimeException("Unmanaged case");
			}
		}

		private void store(LeafContext<? extends C> context, Getter<C, Value> getter) {
			Map<Parameter<?>, Getter<?, ?>> getters = contextParameters.get(context);
			getters.put(parameter, getter);
		}
	}

	/**
	 * A {@link Getter} aims at reading a specific parameter from a
	 * {@link Context}. When {@link #get(Object)} is called, the given
	 * {@link Context} should be read to return the proper value.
	 * 
	 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
	 *
	 * @param <C>
	 *            The {@link Context} to read
	 * @param <Value>
	 *            The value to read
	 */
	public static interface Getter<C, Value> {
		/**
		 * 
		 * @param context
		 *            the {@link Context} to read
		 * @return the value retrieved from the {@link Context}
		 */
		public Value get(C context);
	}

	/**
	 * Use this method to tell how to assign a {@link Parameter} value to a
	 * given {@link Type} of algorithm.
	 * 
	 * @param parameter
	 *            the {@link Parameter} to assign
	 */
	public <Value> ValueAssigner<Value> assign(Parameter<Value> parameter) {
		return new ValueAssigner<Value>(parameter);
	}

	public class ValueAssigner<Value> {
		private final Parameter<Value> parameter;

		public ValueAssigner(Parameter<Value> parameter) {
			this.parameter = parameter;
		}

		/**
		 * 
		 * @param type
		 *            the {@link Type} of the algorithm to configure
		 */
		public <A extends Algorithm> AlgorithmWriter<A, Value> to(Type<A> type) {
			return new AlgorithmWriter<A, Value>(parameter, type);
		}
	}

	public class AlgorithmWriter<A extends Algorithm, Value> {
		private final Parameter<Value> parameter;
		private final Type<A> type;

		public AlgorithmWriter(Parameter<Value> parameter, Type<A> type) {
			this.parameter = parameter;
			this.type = type;
		}

		/**
		 * 
		 * @param setter
		 *            the {@link Setter} to use for configuring the algorithm
		 *            with the given {@link Parameter}
		 */
		public void with(Setter<A, Value> setter) {
			if (type instanceof LeafType) {
				store((LeafType<A>) type, setter);
			} else if (type instanceof ComposedType) {
				List<ComposedType<? extends A>> remaining = new LinkedList<>();
				remaining.add((ComposedType<A>) type);
				while (!remaining.isEmpty()) {
					ComposedType<? extends A> composedType = remaining.remove(0);
					for (Type<? extends A> subtype : composedType.getSubTypes()) {
						if (subtype instanceof LeafType) {
							store((LeafType<? extends A>) subtype, setter);
						} else if (subtype instanceof ComposedType) {
							remaining.add((ComposedType<? extends A>) subtype);
						} else {
							throw new RuntimeException("Unmanaged case");
						}
					}
				}
			} else {
				throw new RuntimeException("Unmanaged case");
			}
		}

		private void store(LeafType<? extends A> type, Setter<A, Value> setter) {
			Map<Parameter<?>, Setter<?, ?>> setters = typeParameters.get(type);
			setters.put(parameter, setter);
		}
	}

	/**
	 * A {@link Setter} aims at configuring a specific {@link Parameter} of an
	 * algorithm. When {@link #set(Object, Object)} is called, the given
	 * algorithm should be configured with the given value.
	 * 
	 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
	 *
	 * @param <Algorithm>
	 *            The algorithm to configure
	 * @param <Value>
	 *            The value to apply
	 */
	public static interface Setter<Algorithm, Value> {
		/**
		 * 
		 * @param algorithm
		 *            the algorithm to configure
		 * @param value
		 *            the value to apply
		 */
		public void set(Algorithm algorithm, Value value);
	}

	/**
	 * Use this method to refine the values of a {@link Parameter}, like
	 * replacing its value or throwing an exception.
	 * 
	 * @param parameter
	 *            the {@link Parameter} to manage
	 */
	public <Value> ValueSelector<Value> when(Parameter<Value> parameter) {
		return new ValueSelector<Value>(parameter);
	}

	public class ValueSelector<Value> {

		private final Parameter<Value> parameter;

		private ValueSelector(Parameter<Value> parameter) {
			this.parameter = parameter;
		}

		/**
		 * If the {@link Condition} provided is satisfied by the value of the
		 * {@link Parameter}, the following operation will be applied.
		 * 
		 * @param condition
		 *            the {@link Condition} to check
		 */
		public AlgorithmSelector<Value> satisfies(Condition<Value> condition) {
			return new AlgorithmSelector<Value>(parameter, condition);
		}

		/**
		 * Independently of the value, the following operation will be applied.
		 * It is equivalent to <code>satisfies((v) -> true)</code>.
		 */
		public AlgorithmSelector<Value> getAnyValue() {
			return satisfies((v) -> true);
		}
	}

	public static interface Condition<Value> {
		public boolean isSatisfiedBy(Value value);
	}

	public class AlgorithmSelector<Value> {

		private final Parameter<Value> parameter;
		private final Condition<Value> condition;

		private AlgorithmSelector(Parameter<Value> parameter, Condition<Value> condition) {
			this.parameter = parameter;
			this.condition = condition;
		}

		/**
		 * The operation applies to any algorithm.
		 */
		public ReplacementSelector<Value> inAnyAlgorithm() {
			return new ReplacementSelector<Value>(parameter, (a) -> true, condition);
		}

		/**
		 * The operation applies only to the algorithm which corresponds to the
		 * given {@link Type} and {@link Context}.
		 */
		public ReplacementSelector<Value> in(Type<?> type, Context<?> context) {
			return new ReplacementSelector<Value>(parameter, (a) -> type.isTypeOf(a) && context.isContextOf(a),
					condition);
		}

		/**
		 * The operation applies only to the algorithms which correspond to the
		 * given {@link Type}.
		 */
		public ReplacementSelector<Value> inAll(Type<?> type) {
			return new ReplacementSelector<Value>(parameter, (a) -> type.isTypeOf(a), condition);
		}

		/**
		 * The operation applies only to the algorithms which correspond to the
		 * given {@link Context}.
		 */
		public ReplacementSelector<Value> inAll(Context<?> context) {
			return new ReplacementSelector<Value>(parameter, (a) -> context.isContextOf(a), condition);
		}
	}

	public class ReplacementSelector<Value> {
		private final Parameter<Value> parameter;
		private final Predicate<Algorithm> selector;
		private final Condition<Value> condition;

		private ReplacementSelector(Parameter<Value> parameter, Predicate<Algorithm> selector,
				Condition<Value> condition) {
			this.parameter = parameter;
			this.selector = selector;
			this.condition = condition;
		}

		/**
		 * Throw a {@link RuntimeException} telling that the value is invalid
		 * for the {@link Parameter}.
		 */
		public final void throwException() {
			replaceBy((Replacer<Value>) (value) -> {
				throw new RuntimeException(value + " is not a valid value for parameter " + parameter);
			});
		}

		/**
		 * Replace the value of the {@link Parameter} by another one.
		 * 
		 * @param replacer
		 *            the replacement method to use
		 */
		public final void replaceBy(Replacer<Value> replacer) {
			Collection<ReplacementDescriptor<?>> rules = parameterReplacers.get(parameter);
			rules.add(new ReplacementDescriptor<>(selector, condition, replacer));
		}

		/**
		 * Replace the value of the {@link Parameter} by another one.
		 * 
		 * @param value
		 *            the replacement value to use
		 */
		public void replaceBy(Value value) {
			replaceBy((Replacer<Value>) (v) -> value);
		}
	}

	public static interface Replacer<Value> {
		public Value replace(Value value);
	}

	private class ReplacementDescriptor<Value> {
		private final Predicate<Algorithm> algorithmSelector;
		private final Condition<Value> valueSelector;
		private final Replacer<Value> replacer;

		public ReplacementDescriptor(Predicate<Algorithm> algorithmSelector, Condition<Value> valueSelector,
				Replacer<Value> replacer) {
			this.algorithmSelector = algorithmSelector;
			this.valueSelector = valueSelector;
			this.replacer = replacer;
		}

		public boolean isApplicableOn(Algorithm algorithm, Value value) {
			return algorithmSelector.test(algorithm) && valueSelector.isSatisfiedBy(value);
		}

		public Value apply(Value value) {
			return replacer.replace(value);
		}
	}
}
